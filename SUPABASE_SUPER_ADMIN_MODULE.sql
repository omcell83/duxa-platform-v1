-- =====================================================
-- DUXA SUPER ADMIN MODULE - DATABASE SCHEMA
-- Mevcut tabloları koruyarak yeni tablolar ve ilişkiler oluşturur
-- =====================================================

-- =====================================================
-- 1. PROFILES TABLE (Admin Users / Personel Bilgileri)
-- =====================================================
-- Supabase auth.users ile ilişkili profil tablosu
-- Eğer zaten varsa ALTER, yoksa CREATE yapılacak
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email text UNIQUE NOT NULL,
  full_name text,
  role text NOT NULL DEFAULT 'user' CHECK (role IN ('super_admin', 'support', 'sales', 'user')),
  phone text,
  department text,
  position text,
  is_active boolean DEFAULT true,
  last_login_at timestamp with time zone,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Index for role lookups
CREATE INDEX IF NOT EXISTS profiles_role_idx ON public.profiles(role);
CREATE INDEX IF NOT EXISTS profiles_email_idx ON public.profiles(email);

-- =====================================================
-- 2. TENANTS TABLE EXTENSION
-- =====================================================
-- Mevcut tenants tablosunu genişletiyoruz (ALTER TABLE)
ALTER TABLE public.tenants 
  ADD COLUMN IF NOT EXISTS commercial_name text, -- Ticari Unvan
  ADD COLUMN IF NOT EXISTS brand_name text, -- Marka Adı
  ADD COLUMN IF NOT EXISTS tax_number text, -- Vergi No
  ADD COLUMN IF NOT EXISTS contact_email text, -- İletişim Email
  ADD COLUMN IF NOT EXISTS contact_phone text, -- İletişim Telefon
  ADD COLUMN IF NOT EXISTS contact_address text, -- İletişim Adres
  ADD COLUMN IF NOT EXISTS status text DEFAULT 'active' CHECK (status IN ('active', 'passive', 'suspended')), -- Status (mevcut varsa değiştirmez)
  ADD COLUMN IF NOT EXISTS is_online boolean DEFAULT false, -- Online/Offline durumu
  ADD COLUMN IF NOT EXISTS contract_date date, -- Sözleşme tarihi
  ADD COLUMN IF NOT EXISTS payment_period text CHECK (payment_period IN ('monthly', 'quarterly', 'yearly')), -- Ödeme periyodu
  ADD COLUMN IF NOT EXISTS last_payment_status text CHECK (last_payment_status IN ('paid', 'pending', 'overdue', 'cancelled')), -- Son ödeme durumu
  ADD COLUMN IF NOT EXISTS last_payment_date date, -- Son ödeme tarihi
  ADD COLUMN IF NOT EXISTS updated_at timestamp with time zone DEFAULT timezone('utc'::text, now());

-- Indexes for tenants
CREATE INDEX IF NOT EXISTS tenants_status_idx ON public.tenants(status);
CREATE INDEX IF NOT EXISTS tenants_tax_number_idx ON public.tenants(tax_number);
CREATE INDEX IF NOT EXISTS tenants_is_online_idx ON public.tenants(is_online);

-- =====================================================
-- 3. SUBSCRIPTIONS TABLE (Abonelikler ve Ödemeler)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.subscriptions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_id bigint NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  contract_content text, -- Sözleşme içeriği
  contract_price decimal(10,2) NOT NULL, -- Sözleşme fiyatı
  contract_date date NOT NULL, -- Sözleşme tarihi
  contract_start_date date, -- Sözleşme başlangıç tarihi
  contract_end_date date, -- Sözleşme bitiş tarihi
  special_terms text, -- Sözleşme özel maddeleri (JSON veya text)
  discount_rate decimal(5,2) DEFAULT 0 CHECK (discount_rate >= 0 AND discount_rate <= 100), -- İndirim oranı (0-100)
  hardware_list jsonb, -- Donanım listesi (JSON formatında)
  hardware_total_price decimal(10,2) DEFAULT 0, -- Donanım toplam fiyatı
  hardware_payment_method text CHECK (hardware_payment_method IN ('one_time', 'installment', 'rental')), -- Donanım ödeme şekli
  payment_status text NOT NULL DEFAULT 'pending' CHECK (payment_status IN ('paid', 'pending', 'overdue', 'cancelled', 'refunded')), -- Ödeme durumu
  payment_date date, -- Ödeme tarihi
  payment_amount decimal(10,2), -- Ödeme tutarı
  payment_method text CHECK (payment_method IN ('credit_card', 'bank_transfer', 'cash', 'check', 'other')), -- Ödeme şekli
  payment_reference text, -- Ödeme referans numarası
  invoice_number text, -- Fatura numarası
  notes text, -- Notlar
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  created_by uuid REFERENCES public.profiles(id) -- İşlemi yapan admin
);

-- Indexes for subscriptions
CREATE INDEX IF NOT EXISTS subscriptions_tenant_id_idx ON public.subscriptions(tenant_id);
CREATE INDEX IF NOT EXISTS subscriptions_contract_date_idx ON public.subscriptions(contract_date);
CREATE INDEX IF NOT EXISTS subscriptions_payment_status_idx ON public.subscriptions(payment_status);
CREATE INDEX IF NOT EXISTS subscriptions_payment_date_idx ON public.subscriptions(payment_date);

-- =====================================================
-- 4. HARDWARE_INVENTORY TABLE (Donanım Envanteri)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.hardware_inventory (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  serial_number text UNIQUE NOT NULL, -- Seri No
  device_type text NOT NULL CHECK (device_type IN ('kiosk', 'pos')), -- Cihaz Tipi
  status text NOT NULL DEFAULT 'in_stock' CHECK (status IN ('in_stock', 'rented', 'under_repair', 'broken', 'decommissioned')), -- Durum
  tenant_id bigint REFERENCES public.tenants(id) ON DELETE SET NULL, -- Zimmetli olduğu Tenant ID
  warehouse_entry_date date, -- Depoya giriş tarihi
  assignment_date date, -- Zimmet tarihi
  return_date date, -- Depodan çıkış/geri dönüş tarihi
  model text, -- Model bilgisi
  manufacturer text, -- Üretici
  purchase_price decimal(10,2), -- Alış fiyatı
  notes text, -- Notlar
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Indexes for hardware_inventory
CREATE INDEX IF NOT EXISTS hardware_inventory_serial_number_idx ON public.hardware_inventory(serial_number);
CREATE INDEX IF NOT EXISTS hardware_inventory_device_type_idx ON public.hardware_inventory(device_type);
CREATE INDEX IF NOT EXISTS hardware_inventory_status_idx ON public.hardware_inventory(status);
CREATE INDEX IF NOT EXISTS hardware_inventory_tenant_id_idx ON public.hardware_inventory(tenant_id);

-- =====================================================
-- 5. SYSTEM_TRANSLATIONS TABLE (Sistem Çevirileri)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.system_translations (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key text NOT NULL, -- Çeviri anahtarı
  lang_code varchar(10) NOT NULL, -- Dil kodu (tr, en, de, fr, vb.)
  value text NOT NULL, -- Çeviri değeri
  context text, -- Kullanım bağlamı (opsiyonel)
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  UNIQUE(key, lang_code) -- Aynı key ve lang_code kombinasyonu tekrar edemez
);

-- Indexes for system_translations
CREATE INDEX IF NOT EXISTS system_translations_key_idx ON public.system_translations(key);
CREATE INDEX IF NOT EXISTS system_translations_lang_code_idx ON public.system_translations(lang_code);
CREATE INDEX IF NOT EXISTS system_translations_key_lang_idx ON public.system_translations(key, lang_code);

-- =====================================================
-- 6. MAIL_CONFIGS TABLE (Email Ayarları ve Şablonlar)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mail_configs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL UNIQUE, -- Konfigürasyon adı (örn: 'default_smtp', 'welcome_template')
  config_type text NOT NULL CHECK (config_type IN ('smtp', 'template')), -- Konfigürasyon tipi
  smtp_host text, -- SMTP Host
  smtp_port integer, -- SMTP Port
  smtp_username text, -- SMTP Kullanıcı adı
  smtp_password text, -- SMTP Şifre (encrypted olarak saklanmalı)
  smtp_encryption text CHECK (smtp_encryption IN ('none', 'ssl', 'tls')), -- Şifreleme tipi
  smtp_from_email text, -- Gönderen email
  smtp_from_name text, -- Gönderen adı
  template_subject text, -- Email konusu (şablonlar için)
  template_body_html text, -- Email HTML içeriği
  template_body_text text, -- Email text içeriği
  template_variables jsonb, -- Şablon değişkenleri (JSON formatında)
  is_active boolean DEFAULT true, -- Aktif mi?
  is_default boolean DEFAULT false, -- Varsayılan mı?
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Indexes for mail_configs
CREATE INDEX IF NOT EXISTS mail_configs_config_type_idx ON public.mail_configs(config_type);
CREATE INDEX IF NOT EXISTS mail_configs_is_active_idx ON public.mail_configs(is_active);
CREATE INDEX IF NOT EXISTS mail_configs_is_default_idx ON public.mail_configs(is_default);

-- =====================================================
-- 7. TRIGGERS - Updated_at otomatik güncelleme ve Role değişikliği kontrolü
-- =====================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Function to prevent users from changing their own role
CREATE OR REPLACE FUNCTION prevent_role_change()
RETURNS TRIGGER AS $$
BEGIN
    -- If role is being changed and user is not super_admin, prevent it
    IF OLD.role IS DISTINCT FROM NEW.role THEN
        -- Check if current user is super_admin
        IF NOT EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid() AND role = 'super_admin' AND is_active = true
        ) THEN
            -- User is trying to change role but is not super_admin
            RAISE EXCEPTION 'Only super_admin can change user roles';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ language 'plpgsql' SECURITY DEFINER;

-- Apply triggers to all tables with updated_at
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_tenants_updated_at BEFORE UPDATE ON public.tenants FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_hardware_inventory_updated_at BEFORE UPDATE ON public.hardware_inventory FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_system_translations_updated_at BEFORE UPDATE ON public.system_translations FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_mail_configs_updated_at BEFORE UPDATE ON public.mail_configs FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Trigger to prevent role changes by non-super-admin users
CREATE TRIGGER prevent_profiles_role_change BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION prevent_role_change();

-- =====================================================
-- 8. ROW LEVEL SECURITY (RLS) - ENABLE
-- =====================================================
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.hardware_inventory ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.system_translations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mail_configs ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- 9. RLS POLICIES - Super Admin Only INSERT/UPDATE/DELETE
-- =====================================================

-- Helper function to check if user is super_admin
CREATE OR REPLACE FUNCTION public.is_super_admin(user_id uuid)
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = user_id AND role = 'super_admin' AND is_active = true
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- PROFILES POLICIES
-- =====================================================

-- SELECT: Super admins can see all, others can see only themselves
CREATE POLICY "profiles_select_policy"
ON public.profiles FOR SELECT
TO public
USING (
  auth.uid() = id OR 
  public.is_super_admin(auth.uid())
);

-- INSERT: Only super admins can create profiles
CREATE POLICY "profiles_insert_policy"
ON public.profiles FOR INSERT
TO public
WITH CHECK (public.is_super_admin(auth.uid()));

-- UPDATE: Super admins can update all, users can update themselves
-- Note: Role change restriction should be handled at application layer or via trigger
CREATE POLICY "profiles_update_policy"
ON public.profiles FOR UPDATE
TO public
USING (
  auth.uid() = id OR 
  public.is_super_admin(auth.uid())
)
WITH CHECK (
  auth.uid() = id OR 
  public.is_super_admin(auth.uid())
);

-- DELETE: Only super admins can delete
CREATE POLICY "profiles_delete_policy"
ON public.profiles FOR DELETE
TO public
USING (public.is_super_admin(auth.uid()));

-- =====================================================
-- TENANTS POLICIES
-- =====================================================

-- SELECT: All authenticated users can read (but tenant isolation applies in application layer)
CREATE POLICY "tenants_select_policy"
ON public.tenants FOR SELECT
TO authenticated
USING (true);

-- INSERT: Only super admins
CREATE POLICY "tenants_insert_policy"
ON public.tenants FOR INSERT
TO public
WITH CHECK (public.is_super_admin(auth.uid()));

-- UPDATE: Only super admins
CREATE POLICY "tenants_update_policy"
ON public.tenants FOR UPDATE
TO public
USING (public.is_super_admin(auth.uid()))
WITH CHECK (public.is_super_admin(auth.uid()));

-- DELETE: Only super admins
CREATE POLICY "tenants_delete_policy"
ON public.tenants FOR DELETE
TO public
USING (public.is_super_admin(auth.uid()));

-- =====================================================
-- SUBSCRIPTIONS POLICIES
-- =====================================================

-- SELECT: Super admins can see all, authenticated users can see (tenant isolation at application layer)
-- Note: For tenant-specific access, filter by tenant_id in application code
CREATE POLICY "subscriptions_select_policy"
ON public.subscriptions FOR SELECT
TO authenticated
USING (true);

-- INSERT: Only super admins
CREATE POLICY "subscriptions_insert_policy"
ON public.subscriptions FOR INSERT
TO public
WITH CHECK (public.is_super_admin(auth.uid()));

-- UPDATE: Only super admins
CREATE POLICY "subscriptions_update_policy"
ON public.subscriptions FOR UPDATE
TO public
USING (public.is_super_admin(auth.uid()))
WITH CHECK (public.is_super_admin(auth.uid()));

-- DELETE: Only super admins
CREATE POLICY "subscriptions_delete_policy"
ON public.subscriptions FOR DELETE
TO public
USING (public.is_super_admin(auth.uid()));

-- =====================================================
-- HARDWARE_INVENTORY POLICIES
-- =====================================================

-- SELECT: Authenticated users can see (tenant isolation at application layer)
-- Note: For tenant-specific access, filter by tenant_id in application code
CREATE POLICY "hardware_inventory_select_policy"
ON public.hardware_inventory FOR SELECT
TO authenticated
USING (true);

-- INSERT: Only super admins
CREATE POLICY "hardware_inventory_insert_policy"
ON public.hardware_inventory FOR INSERT
TO public
WITH CHECK (public.is_super_admin(auth.uid()));

-- UPDATE: Only super admins
CREATE POLICY "hardware_inventory_update_policy"
ON public.hardware_inventory FOR UPDATE
TO public
USING (public.is_super_admin(auth.uid()))
WITH CHECK (public.is_super_admin(auth.uid()));

-- DELETE: Only super admins
CREATE POLICY "hardware_inventory_delete_policy"
ON public.hardware_inventory FOR DELETE
TO public
USING (public.is_super_admin(auth.uid()));

-- =====================================================
-- SYSTEM_TRANSLATIONS POLICIES
-- =====================================================

-- SELECT: Everyone can read translations (public access for multilingual support)
CREATE POLICY "system_translations_select_policy"
ON public.system_translations FOR SELECT
TO public
USING (true);

-- INSERT: Only super admins
CREATE POLICY "system_translations_insert_policy"
ON public.system_translations FOR INSERT
TO public
WITH CHECK (public.is_super_admin(auth.uid()));

-- UPDATE: Only super admins
CREATE POLICY "system_translations_update_policy"
ON public.system_translations FOR UPDATE
TO public
USING (public.is_super_admin(auth.uid()))
WITH CHECK (public.is_super_admin(auth.uid()));

-- DELETE: Only super admins
CREATE POLICY "system_translations_delete_policy"
ON public.system_translations FOR DELETE
TO public
USING (public.is_super_admin(auth.uid()));

-- =====================================================
-- MAIL_CONFIGS POLICIES
-- =====================================================

-- SELECT: Only super admins can see mail configs (sensitive data)
CREATE POLICY "mail_configs_select_policy"
ON public.mail_configs FOR SELECT
TO authenticated
USING (public.is_super_admin(auth.uid()));

-- INSERT: Only super admins
CREATE POLICY "mail_configs_insert_policy"
ON public.mail_configs FOR INSERT
TO public
WITH CHECK (public.is_super_admin(auth.uid()));

-- UPDATE: Only super admins
CREATE POLICY "mail_configs_update_policy"
ON public.mail_configs FOR UPDATE
TO public
USING (public.is_super_admin(auth.uid()))
WITH CHECK (public.is_super_admin(auth.uid()));

-- DELETE: Only super admins
CREATE POLICY "mail_configs_delete_policy"
ON public.mail_configs FOR DELETE
TO public
USING (public.is_super_admin(auth.uid()));

-- =====================================================
-- NOTES & IMPORTANT REMINDERS
-- =====================================================
-- 1. Bu SQL dosyasını Supabase SQL Editor'de çalıştırın
-- 2. İlk super_admin kullanıcısını manuel olarak oluşturmanız gerekecek:
--    INSERT INTO public.profiles (id, email, full_name, role) 
--    VALUES ('<auth_user_uuid>', 'admin@example.com', 'Super Admin', 'super_admin');
-- 3. Mevcut tenants tablosundaki 'status' alanı varsa CHECK constraint eklenmeyebilir, 
--    bu durumda ALTER TABLE komutunu manuel olarak düzenleyin
-- 4. RLS politikaları, uygulama katmanında tenant isolation için ek kontroller gerektirebilir
-- 5. SMTP şifrelerinin encrypted olarak saklanması önerilir (application layer'da)
