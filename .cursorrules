
# DUXA PLATFORM - SECURITY & CODING MANIFESTO

You are creating a high-security, offline-first restaurant SaaS called "Duxa".
Prioritize STABILITY, SECURITY, and TYPE SAFETY over speed.

## 0. GOLDEN RULE: ZERO BUILD ERRORS (STRICT MODE)
- **Verify Before Output:** Never output code without mentally (or actually) verifying it against TypeScript rules.
- **Type-Check:** When using Composer (Agent), always run `npm run type-check` (or `tsc --noEmit`) before finishing. If there are errors, FIX THEM automatically.
- **No `any`:** Strict TypeScript is non-negotiable. Define proper interfaces for all data.
- **No Hallucinations:** Do not import non-existent libraries or assume file paths. Check first.

## 1. SECURITY RULES (NON-NEGOTIABLE)
- **RLS Awareness:** Every database query MUST respect Supabase Row Level Security.
- **Tenant Isolation:** Always filter queries by `tenant_id`. Never allow cross-tenant data leaks.
- **Input Validation:** Use `zod` to validate ALL user inputs on both client and server.
- **No Secrets in Code:** Never hardcode API keys. Use `process.env`.
- **SQL Injection:** Use parameterized queries via Supabase SDK.

## 2. ARCHITECTURE (HYBRID)
- **Web App (Next.js):** Runs on Cloud (Coolify). Uses Supabase directly.
- **Kiosk App (Electron):** Runs Offline. Uses local SQLite encrypted with SQLCipher.
- **Sync Engine:** Kiosk syncs to Supabase when online.

## 3. ERROR HANDLING & SELF-HEALING
- Wrap critical async operations in try/catch blocks.
- If an API fails, the UI must show a user-friendly "Offline" or "Error" state, never crash (White Screen of Death).
- Use React Error Boundaries for component isolation.

## 4. TECH STACK
- **Framework:** Next.js 14+ (App Router) - Strict separation of Server/Client Components.
- **Language:** TypeScript (Strict).
- **Styling:** Tailwind CSS, Shadcn UI.
- **State:** Zustand (Client), TanStack Query (Server State).
- **DB:** Supabase (Cloud), SQLite (Local).

## 5. UI/UX DESIGN SYSTEM (THEME: ADA/TAILUS + SHADCN)
- **Design Source:** We use **Tailus UI** (Zinc/Neutral) aesthetics mapped to **Shadcn UI** components.
- **STRICT Semantic Colors (NO HARDCODING):**
  - **Forbidden:** NEVER use `bg-white`, `bg-black`, `bg-slate-50`, `bg-gray-100` or arbitrary Hex codes (e.g., `#fff`).
  - **Mandatory:** ALWAYS use semantic classes mapped in `globals.css`:
    - `bg-background` / `text-foreground` (Main Page Backgrounds)
    - `bg-card` / `text-card-foreground` (Cards, Panels, Form Containers)
    - `bg-popover` / `text-popover-foreground` (Modals, Dropdowns, Sheets)
    - `bg-primary` / `text-primary-foreground` (Action Buttons)
    - `bg-muted` (Secondary/Disabled states)
- **Modal & Overlay Transparency Rule:**
  - Every `DialogContent`, `SheetContent`, or `PopoverContent` MUST explicitly have `bg-popover` or `bg-card` in its className.
  - **Never** allow modals to rely on default transparency. They must be OPAQUE (Solid).
- **Typography & Borders:**
  - Use `text-muted-foreground` for secondary text (descriptions).
  - Use `border-border` for all dividers and inputs. Never use `border-gray-200`.

## 6. MODULE & PAGE CREATION PROTOCOL
- **Layout Integrity:** Every new page (`page.tsx`) or layout (`layout.tsx`) must explicitly set `bg-background` in its outer container to prevent "transparent page" issues.
- **Variable Mapping Awareness:** Do not overwrite CSS variables in `globals.css`. If a color looks wrong, check the mapping between Tailus variables (`--color-white`) and Shadcn variables (`--background`), but do not hardcode colors in the component.
- **Dark Mode Compliance:** When writing classes, assume the background might be dark. e.g., never write `text-black` (it disappears in dark mode), always write `text-foreground`.

## 7. DOCUMENTATION MAINTENANCE PROTOCOL (LIVING DOCS)

You are responsible for maintaining the project's living documentation in `docs/system-map.json`.

**TRIGGER:** Whenever you create a new file, delete a file, or significantly change the functionality of an existing file/page.

**ACTION:** You MUST update `docs/system-map.json` immediately after the code change.

**RULES FOR UPDATING:**
1.  **For Files (`files` array):**
    * If a new file is created, add its `path`, `type` (page, component, server-action, utility, hook), and a concise `description` of what it does.
    * If a file is modified significantly, update its `description` to reflect the new logic.
    * If a file is deleted, remove it from the array.

2.  **For Routes (`routes` array):**
    * If a new `page.tsx` creates a visible URL route, add the full URL (e.g., `https://duxa.pro/dashboard/new-page`) and a user-centric description.
    * Never hide the full URL protocol or domain.

**CRITICAL:** Do not ask the user if they want to update the docs. Just do it as part of the task. Keep the descriptions short but technical enough for a developer to understand.